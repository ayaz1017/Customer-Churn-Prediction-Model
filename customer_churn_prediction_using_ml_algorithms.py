# -*- coding: utf-8 -*-
"""Customer Churn Prediction Using ML algorithms

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ZXmoVpFJJ4QQxLJpw__Ve42A8wvu0ER
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from imblearn.over_sampling import SMOTE
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score

df=pd.read_csv('churn.csv')

df

df.info()

df.isnull().sum()

df.describe()

df=df.drop(columns=['customerID'])

objects_columns=df.select_dtypes(include=['object']).columns

objects_columns

encoders={}
for columns in objects_columns:
  encoders[columns]=LabelEncoder()
  df[columns]=encoders[columns].fit_transform(df[columns])

  with open("encoders.pkl", "wb") as f:
    pickle.dump(encoders, f)

corr=df.corr()
plt.figure(figsize=(10,10))
sns.heatmap(corr,annot=True)

plt.figure(figsize=(4,3))
sns.boxplot(x='gender', y='tenure', data=df)
plt.title('Gender vs. Tenure')
plt.show()

plt.figure(figsize=(5,3))
sns.histplot(df['MonthlyCharges'],bins=30,kde=True)
plt.title('Histogram of Monthly Charges')
plt.xlabel('Monthly Charges')
plt.ylabel('Frequency')
plt.show()

sns.pairplot(df)

X=df.drop('Churn',axis=1)
Y=df['Churn']

X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.2,random_state=42)

scaler=StandardScaler()
X_train=scaler.fit_transform(X_train)
X_test=scaler.transform(X_test)

print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_train.shape)

X_train

dt=DecisionTreeClassifier()
dt.fit(X_train,Y_train)
y_pred_dt=dt.predict(X_test)

accuracy_dt=accuracy_score(Y_test,y_pred_dt)
precision_dt=precision_score(Y_test, y_pred_dt),
recall_dt=recall_score(Y_test, y_pred_dt),
f1_dt=f1_score(Y_test, y_pred_dt),

print('Accuracy:',accuracy_dt)
print('Precision:',precision_dt)
print('Recall:',recall_dt)
print('F1_score:',f1_dt)

from sklearn.tree import plot_tree
plt.figure(figsize=(30,25))
plot_tree(dt, filled=True, feature_names=X.columns, class_names=['0','1'], rounded=True)
plt.show()

rf=RandomForestClassifier()
rf.fit(X_train,Y_train)
y_pred_rf=rf.predict(X_test)

accuracy_rf=accuracy_score(Y_test,y_pred_rf)
precision_rf=precision_score(Y_test, y_pred_rf),
recall_rf=recall_score(Y_test, y_pred_rf),
f1_rf=f1_score(Y_test, y_pred_rf),

print('Accuracy:',accuracy_rf)
print('Precision:',precision_rf)
print('Recall:',recall_rf)
print('F1_score:',f1_rf)

plt.figure(figsize=(30,25))
plot_tree(rf.estimators_[0], filled=True, feature_names=X.columns, class_names=['0','1'], rounded=True)
plt.show()

svm=SVC()
svm.fit(X_train,Y_train)
y_pred_svm=svm.predict(X_test)

accuracy_svm=accuracy_score(Y_test,y_pred_svm)
precision_svm=precision_score(Y_test, y_pred_svm),
recall_svm=recall_score(Y_test, y_pred_svm),
f1_svm=f1_score(Y_test, y_pred_svm),

print('Accuracy:',accuracy_svm)
print('Precision:',precision_svm)
print('Recall:',recall_svm)
print('F1_score:',f1_svm)

knn=KNeighborsClassifier()
knn.fit(X_train,Y_train)
y_pred_knn=knn.predict(X_test)

accuracy_knn=accuracy_score(Y_test,y_pred_knn)
precision_knn=precision_score(Y_test, y_pred_knn),
recall_knn=recall_score(Y_test, y_pred_knn),
f1_knn=f1_score(Y_test, y_pred_knn),

print('Accuracy:',accuracy_knn)
print('Precision:',precision_knn)
print('Recall:',recall_knn)
print('F1_score:',f1_knn)

plt.figure(figsize=(8, 6))
plt.scatter(Y_test, y_pred_knn, alpha=0.5)
plt.xlabel("Actual Values")
plt.ylabel("Predicted Values")
plt.title("KNN: Actual vs. Predicted")
plt.plot([min(Y_test), max(Y_test)], [min(Y_test), max(Y_test)], linestyle='--', color='red', linewidth=2) # Add diagonal line
plt.show()

GBC=GradientBoostingClassifier()
GBC.fit(X_train,Y_train)
y_pred_GBC=GBC.predict(X_test)

accuracy_GBC=accuracy_score(Y_test,y_pred_GBC)
precision_GBC=precision_score(Y_test, y_pred_GBC),
recall_GBC=recall_score(Y_test, y_pred_GBC),
f1_GBC=f1_score(Y_test, y_pred_GBC),

print('Accuracy:',accuracy_GBC)
print('Precision:',precision_GBC)
print('Recall:',recall_GBC)
print('F1_score:',f1_GBC)

results = {
    'Model': [ 'Decision Tree', 'Random Forest', 'SVM', 'KNN', 'Gradient Boosting'],
    'Accuracy': [ accuracy_dt, accuracy_rf, accuracy_svm, accuracy_knn, accuracy_GBC],
    'Precision': [ precision_dt[0], precision_rf[0], precision_svm[0], precision_knn[0], precision_GBC[0]],
    'Recall': [ recall_dt[0], recall_rf[0], recall_svm[0], recall_knn[0], recall_GBC[0]],
    'F1-Score': [ f1_dt, f1_rf, f1_svm, f1_knn, f1_GBC]
}

results_df = pd.DataFrame(results)
results_df

import pandas as pd
import matplotlib.pyplot as plt

# Ensure these are single float values, not tuples/lists
results = {
    'Model': [ 'Decision Tree', 'Random Forest', 'SVM', 'KNN', 'Gradient Boosting'],
    'Accuracy': [ accuracy_dt, accuracy_rf, accuracy_svm, accuracy_knn, accuracy_GBC],
    'Precision': [ precision_dt, precision_rf, precision_svm, precision_knn, precision_GBC],
    'Recall': [ recall_dt, recall_rf, recall_svm, recall_knn, recall_GBC],
    'F1-Score': [ f1_dt, f1_rf, f1_svm, f1_knn, f1_GBC]
}

results_df = pd.DataFrame(results)

# Plotting
plt.figure(figsize=(8,3))
plt.plot(results_df['Model'], results_df['Accuracy'], marker='o', label='Accuracy')

plt.xlabel("Models")
plt.ylabel("Scores")
plt.title("Comparison of Model Performance")
plt.xticks(rotation=45, ha='right')
plt.legend()
plt.tight_layout()
plt.show()

best_model_accuracy = results_df.loc[results_df['Accuracy'].idxmax()]
best_model_f1 = results_df.loc[results_df['F1-Score'].idxmax()]

print("Best model based on accuracy:")
print(best_model_accuracy)

print("\nBest model based on F1-Score:")
best_model_f1

import pickle
model_data = {"model": GBC, "features_names": X.columns.tolist()}

with open("customer_churn_model.pkl", "wb") as f:
  pickle.dump(model_data, f)

# load teh saved model and the feature names
with open("customer_churn_model.pkl", "rb") as f:
  model_data = pickle.load(f)
  load_model = model_data["model"]
  features_names = model_data["features_names"]

print(load_model)
print(features_names)

import os
print(os.listdir())

for column, encoder in encoders.items():
    print(f"Column: {column}, Encoder Classes: {encoder.classes_}")

import pandas as pd
import pickle
import numpy as np

# Function to get user input
def get_user_input():
    input_data = {}

    input_data['gender'] = input("Enter Gender (Male/Female): ")
    input_data['SeniorCitizen'] = int(input("Enter Senior Citizen (0/1): "))
    input_data['Partner'] = input("Has Partner? (Yes/No): ")
    input_data['Dependents'] = input("Has Dependents? (Yes/No): ")
    input_data['tenure'] = int(input("Enter Tenure (in months): "))
    input_data['PhoneService'] = input("Has Phone Service? (Yes/No): ")
    input_data['MultipleLines'] = input("Multiple Lines (No/Yes/No phone service): ")
    input_data['InternetService'] = input("Internet Service (DSL/Fiber optic/No): ")
    input_data['OnlineSecurity'] = input("Online Security (Yes/No/No internet service): ")
    input_data['OnlineBackup'] = input("Online Backup (Yes/No/No internet service): ")
    input_data['DeviceProtection'] = input("Device Protection (Yes/No/No internet service): ")
    input_data['TechSupport'] = input("Tech Support (Yes/No/No internet service): ")
    input_data['StreamingTV'] = input("Streaming TV (Yes/No/No internet service): ")
    input_data['StreamingMovies'] = input("Streaming Movies (Yes/No/No internet service): ")
    input_data['Contract'] = input("Contract (Month-to-month/One year/Two year): ")
    input_data['PaperlessBilling'] = input("Paperless Billing (Yes/No): ")
    input_data['PaymentMethod'] = input("Payment Method (Electronic check/Mailed check/Bank transfer/Credit card): ")
    input_data['MonthlyCharges'] = float(input("Enter Monthly Charges: "))

    return input_data

# Get user input
input_data = get_user_input()

# Convert input to DataFrame
input_data_df = pd.DataFrame([input_data])

# Load encoders
with open("encoders.pkl", "rb") as f:
    encoders = pickle.load(f)

# Apply encoding to categorical columns
for column, encoder in encoders.items():
    if column in input_data_df:
        try:
            input_data_df[column] = encoder.transform(input_data_df[column].astype(str))
        except ValueError:
            print(f"New category detected in {column}: {input_data_df[column].values}")
            input_data_df[column] = encoder.transform([encoder.classes_[0]])[0]

# Load trained model
with open("customer_churn_model.pkl", "rb") as f:
    model_data = pickle.load(f)
    loaded_model = model_data["model"]
    feature_names = model_data["features_names"]

# Ensure input data matches model's feature set
input_data_df = input_data_df.reindex(columns=feature_names, fill_value=0)

# Convert to numeric
input_data_df = input_data_df.astype(float)

# Make predictions
prediction = loaded_model.predict(input_data_df)
pred_prob = loaded_model.predict_proba(input_data_df)

# Print results
print(f"\nðŸ”¹ Prediction: {'Churn' if prediction[0] == 1 else 'No Churn'}")
print(f"ðŸ”¹ Prediction Probability: {pred_prob}")

